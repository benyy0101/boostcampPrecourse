# -*- coding: utf-8 -*-
"""NN_structure.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LXQjO7BU_5pLDWKCvWS7DVO7IUR-xFXU
"""

import numpy as np
import matplotlib.pyplot as plt
plt.style.use(['seaborn-whitegrid'])

def AND(a,b):
  input = np.array([a,b])

  weight = np.array([0.4,0.4])

  bias = -0.6
  value = np.sum(input*weight) + bias 

  if value <=0:
      return 0
  else:
      return 1

print(AND(0,0))
print(AND(1,0))
print(AND(0,1))
print(AND(1,1))

x1= np.arange(-2,2,0.001)
x2 = np.arange(-2,2,0.001)

bias = -0.6

y = (-0.4* x1 - bias) / 0.4

plt.axvline(x = 0)
plt.axhline(y = 0)

plt.plot(x1,y,'r--')
plt.scatter(0,0, color='orange', marker = 'o', s =150)
plt.scatter(0,1, color='orange', marker = 'o', s =150)
plt.scatter(1,0, color='orange', marker = 'o', s =150)
plt.scatter(1,1, color='black', marker = '^', s =150)

plt.xlim(-0.5,1.5)
plt.ylim(-0.5,1.5)
plt.grid()
plt.show()

def OR(a,b):
  input = np.array([a,b])
  weight = np.array([0.4,0.5])

  bias = -0.3

  value = np.sum(input*weight)+bias
  if value <=0:
    return 0
  else:
    return 1

print(OR(0,0))
print(OR(1,0))
print(OR(0,1))
print(OR(1,1))

x1= np.arange(-2,2,0.001)
x2 = np.arange(-2,2,0.001)

bias = -0.3

y = (-0.4* x1 - bias) / 0.5

plt.axvline(x = 0)
plt.axhline(y = 0)

plt.plot(x1,y,'r--')
plt.scatter(0,0, color='orange', marker = 'o', s =150)
plt.scatter(0,1, color='black', marker = '^', s =150)
plt.scatter(1,0, color='black', marker = '^', s =150)
plt.scatter(1,1, color='black', marker = '^', s =150)

plt.xlim(-0.5,1.5)
plt.ylim(-0.5,1.5)
plt.grid()
plt.show()

def NAND(a,b):
  input = np.array([a,b])
  weight = np.array([-0.6,-0.5])

  bias = 0.7

  value = np.sum(input*weight)+bias
  if value <=0:
    return 0
  else:
    return 1

print(NAND(0,0))
print(NAND(1,0))
print(NAND(0,1))
print(NAND(1,1))

x1= np.arange(-2,2,0.001)
x2 = np.arange(-2,2,0.001)

bias = 0.7

y = (0.6* x1 - bias) / -0.5

plt.axvline(x = 0)
plt.axhline(y = 0)

plt.plot(x1,y,'r--')
plt.scatter(0,0, color='black', marker = 'o', s =150)
plt.scatter(0,1, color='black', marker = 'o', s =150)
plt.scatter(1,0, color='black', marker = 'o', s =150)
plt.scatter(1,1, color='orange', marker = '^', s =150)

plt.xlim(-0.5,1.5)
plt.ylim(-0.5,1.5)
plt.grid()
plt.show()

def XOR(x1,x2):
  s1=NAND(x1,x2)
  s2=OR(x1,x2)
  y = AND(s1,s2)

  return y

print(XOR(0,0))
print(XOR(0,1))
print(XOR(1,0))
print(XOR(1,1))

def step_function(x):
  if x>0:
    return 1
  else:
    return 0

def step_function_for_np(x):

  y = x>0
  return y.astype(np.int)

print(step_function(-1))
print(step_function(5))

a = np.array([5,3,-4,2.0])
print(step_function_for_np(a))

def sigmoid(x):
  return 1/(1+np.exp(-x))

print(sigmoid(3))
print(sigmoid(-3))

plt.grid()
x = np.arange(-5.0, 5.0 ,0.01)

y1 = sigmoid(x)
y2 = step_function_for_np(x)
plt.plot(x,y1,'r-',x,y2,'b--')
plt.show()

def ReLu(x):
  if x> 0:
    return x
  else:
    return 0

print(ReLu(5))
print(ReLu(-3))

def tanh(x):
  return (np.exp(x)-np.exp(-x)) / (np.exp(x)+np.exp(-x))

print(tanh(3))
print(tanh(-3))

def identify_function(x):
  return x

print(identify_function(4))
print(identify_function(-1))

x = np.array([2,-3,0.4])
identify_function(x)

def softmax(a):
  exp_a = np.exp(a)
  sum_exp_a = np.sum(exp_a)
  y = exp_a / sum_exp_a
  return y

a = np.array([0.3,0.2,4.0,-1.2])

print(softmax(a))
print(np.sum(softmax(a)))

#softmax의 한계: 값이 너무 크면 오버플로우 터짐
A = np.array([1000,900,1050,500])
print(softmax(A))

def softmax_C(a):
  c = np.max(a)
  return (np.exp(a-c)/np.sum(np.exp(a-c)))

A = np.array([1000,900,1050,500])
print(softmax_C(A))

def LeakyReLu(x):
  a = 0.01
  return np.maximum(a*x,x)

x = np.array([0.5,-1.4,4.0])
LeakyReLu(x)

def ELU(x):
  alpha = 1.0
  return (x>=0) * x + (x<0)*alpha*(np.exp(x)-1)

print(ELU(4))
print(ELU(-0.5))

x = np.array([-2,0.1,4])
print(ELU(x))

def sigmoid(x):
  return 1/ (1+np.exp(-x))

X = np.array([1.0,0.5,0.4])
W1 = np.array([[0.1,0.3,0.5 ],
              [0.2,0.4,0.6],
              [0.3,0.5,0.7]])
B1 = np.array([1,1,1])

print(X.shape)
print(W1.shape)
print(B1.shape)

A1 = np.dot(X,W1) + B1
Z1 = sigmoid(A1)

print(A1)
print(Z1)

W2 = np.array([[0.2,0.4,0.6],
               [0.1,0.3,0.5],
               [0.4,0.6,0.8]])
B2 = np.array([1,1,1])

print(W2.shape)
print(B2.shape)

A2 = np.dot(A1,W2) + B2
Z2 = sigmoid(A2)

print(A2)
print(Z2)

W3 = np.array([[0.1,0.3],
              [-0.1,-0.5],
              [0.3,0.5]])

B3 = np.array([1,1])

print(W3.shape)
print(B3.shape)

A3 = np.dot(A2,W3) + B3
Z3=sigmoid(A3)

print(A3)
print(Z3)

W4 = np.array([[0.1,0.2],
               [0.3,0.5]])

B4 = np.array([1,1])

print(W4.shape)
print(B4.shape)

A4 = np.dot(A3,W4)+B4
Y = sigmoid(A4)

print(A4)
print(Y)

def network():
  network={}

  network['W1'] = np.array([[0.1,0.3,0.5 ],
              [0.2,0.4,0.6],
              [0.3,0.5,0.7]])
  network['B1'] = np.array([1,1,1])

  network['W2'] = np.array([[0.2,0.4,0.6],
               [0.1,0.3,0.5],
               [0.4,0.6,0.8]])
  network['B2'] = np.array([1,1,1])

  network['W3'] = np.array([[0.1,0.3],
              [-0.1,-0.5],
              [0.3,0.5]])
  network['B3'] = np.array([1,1])

  network['W4'] = np.array([[0.1,0.2],
               [0.3,0.5]])
  network['B4'] = np.array([1,1])

  return network

def forward(network,x):
  W1,W2,W3,W4 = network['W1'],network['W2'],network['W3'],network['W4']
  B1,B2,B3,B4 = network['B1'],network['B2'],network['B3'],network['B4']

  A1 = np.dot(x,W1) +B1
  Z1 = sigmoid(A1)

  A2 = np.dot(Z1,W2) +B2
  Z2 = sigmoid(A2)

  A3 = np.dot(Z2,W3) +B3
  Z3 = sigmoid(A3)

  A4 = np.dot(Z3,W4) +B4
  y = sigmoid(A4)
  
  return y

net = network()
x = np.array([0.3,1.3,-2.2])

y=forward(net,x)
print(y)

