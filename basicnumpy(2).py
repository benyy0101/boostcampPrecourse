# -*- coding: utf-8 -*-
"""basicNumpy(2).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FDWczj1RnoKE4hxa1ClhB20PF2rvl2Jx
"""

import numpy as np


#reshape: array의 shape의 크기를 변경함, rank를 변경함
test_matrix = [[1,2,3,4],
               [5,6,7,8]]

a = np.array(test_matrix).reshape(8,)

#tip: -1 으로 설정시 size를 기반으로 알아서 채워줌

np.array(test_matrix).reshape(-1,2).shape

np.array(test_matrix).reshape(2,-1,2).shape

#flatten: 다차원 행렬은 펴줌

np.array(test_matrix).flatten()

#Indexing & Slicing

a = np.array([[1,2,3],
             [4,5,6]],
             dtype = int)

print(a)

#기존 list에서 element에 접근하는 방법

a[0][0]

#Numpy에서 추가된 방법
a[0,0]

#Slicing
#Numpy에서는 중간 집합도 추출이 가능함

a = np.array([[1,2,3,0],
              [4,5,6,0],
              [4,5,6,0],
              [4,5,6,0]],
             int)

a[:,2:]
a[1,1:3]

a[1:2, :2]

a = np.arange(100).reshape(10,10)
a

a[:,:-1:2]

#Array creation

#arange: array의 범위를 지정해줘서 자동으로 어레이 생성

np.arange(30)

#np.arange('start','end','step')
np.arange(0,5,0.5)

#zeros: 0으로 찬 array생성

np.zeros(shape=(10,),dtype=np.int8)

np.zeros((2,5))

#ones: 1로 찬 array생성

np.ones((2,5))

#empty: shape만 주고 빈공간을 생성

np.empty(shape=(10,), dtype=np.int8)

np.empty((3,5))

#something_like: 주어진 행렬과 같은 shape의 empty array를 생성

#a = np.arange(100).reshape(10,10)

np.ones_like(a)

#identity: 단위행렬 생성

np.identity(n=3, dtype= np.int8)

#eye: identity와 비슷 , 하지만 k값을 조절가능

#np.eye("row","col", k = "idx")
np.eye(3,5,k =2)
np.eye(3,5,k =0)

#diag: 행렬의 대각값만을 추출

#a = np.arange(100).reshape(10,10)

np.diag(a)

#random smpling: 데이터의 분포에 따른 sampling으로 array를 생성

np.random.uniform(0,1,10).reshape(2,5)

np.random.exponential(scale =2,size=100)

#Operation functions(행렬의 연산)
#sum: ndarray간의 합

a = np.arange(1,11)

a.sum()
a.mean()
a.std()
a.var()

#axis: 모든 operation function을 실행할때 기준이 되는 축

test = np.arange(1,13).reshape(3,4)

test.sum(axis = 1)

test.sum(axis=0)

#concatenate: ndarray끼리 붙임

a = np.array([1,2,3])
b = np.array([1,2,3])

np.vstack((a,b))

c = np.array([[1],[2],[3]])
d = np.array([[1],[2],[3]])

np.hstack((c,d))

np.concatenate((a,b), axis = 1)

np.concatenate((c,d),axis = 0)

#Array operation: elementwise operation

a = np.arange(1,11).reshape(2,5)

a + a

a - a

a * a

#dot: Dot product
#transpose: 전치행렬 생성
a.dot(a.transpose())

#Broadcasting: shape이 다른 array끼리의 연산

test = np.array([[1,2,3],
                 [4,5,6]])

scalar = 3

test + scalar

test - scalar
test // scalar

#scalar 뿐만아니라 조건이 맞는다면 행렬끼리도, 텐서끼리도 브로드캐스팅이 가능

test_matrix = np.arange(1,13).reshape(4,3)
test_vector = np.arange(10,40,10)

test_matrix

test_vector

test_matrix + test_vector

test_matrix * test_vector

# Commented out IPython magic to ensure Python compatibility.
def sclar_vector_product(scalar, vector):
  result = []
  for value in vector:
    result.append(scalar * value)
  return result
  
iternation_max = 100000000
vector = list(range(iternation_max))
scalar = 2
# %timeit sclar_vector_product(scalar, vector) # for loop을 이용한 성능
# %timeit [scalar * value for value in range(iternation_max)]
# list comprehension을 이용한 성능
# %timeit np.arange(iternation_max) * scalar # numpy를 이용한 성능

